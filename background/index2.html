<!DOCTYPE html>
<html lang="en" class="no-js">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Image Grid Pan Effect | Demo 2 | Codrops</title>
		<meta name="description" content="">
		<meta name="keywords" content="">
		<meta name="author" content="Codrops">
		<link rel="shortcut icon" href="favicon.26242483.ico">
		<link rel="stylesheet" href="https://use.typekit.net/eqx3jwb.css">
		<link rel="stylesheet" type="text/css" href="base.98fd6c19.css">
		<style>
			/* Styles for draggable elements */
			body {
				overflow: hidden;
			}
			
			/* Make grid items draggable */
			.grid__item {
				position: relative !important; /* Allow Codrops to control positioning */
				cursor: grab !important;
				user-select: none !important;
				-webkit-user-select: none !important;
				touch-action: none !important;
				z-index: 100 !important;
				width: 150px !important;
				height: 150px !important;
				overflow: visible !important;
				display: flex !important;
				align-items: center !important;
				justify-content: center !important;
				will-change: transform !important;
				transform: translateY(-20vh) !important; /* Move items up */
			}
			
			/* Ensure images display properly */
			.grid__item-img {
				background-size: contain !important;
				background-repeat: no-repeat !important;
				background-position: center !important;
				width: 100% !important;
				height: 100% !important;
				pointer-events: none !important; /* Pass events to parent */
			}
			
			/* Center grid and content */
			.grid {
				pointer-events: auto !important;
				position: fixed !important;
				width: 100% !important;
				height: 100% !important;
				top: 0 !important;
				left: 0 !important;
				display: grid !important;
				grid-template-columns: repeat(50,2%) !important;
				grid-template-rows: repeat(50,2%) !important;
				z-index: 1 !important;
			}
			
			/* Center content and title */
			.content {
				height: 100vh !important;
				max-height: none !important;
				display: flex !important;
				flex-direction: column !important;
				align-items: center !important;
				justify-content: flex-start !important; /* Align to top */
				width: 100vw !important;
				position: relative !important;
				z-index: 2 !important;
			}

			/* Center title */
			.content__title {
				position: absolute !important;
				bottom: 15vh !important; /* Move up from bottom */
				left: 50% !important;
				transform: translateX(-50%) !important;
				text-align: center !important;
				width: auto !important;
				margin: 0 !important;
				z-index: 1000 !important; /* Ensure title is above images */
			}
			
			/* Add dragging class */
			.dragging {
				cursor: grabbing !important;
				z-index: 1000 !important;
			}
		</style>
		<script>document.documentElement.className = "js";

var supportsCssVars = function supportsCssVars() {
  var e,
      t = document.createElement("style");
  return t.innerHTML = "root: { --tmp-var: bold; }", document.head.appendChild(t), e = !!(window.CSS && window.CSS.supports && window.CSS.supports("font-weight", "var(--tmp-var)")), t.parentNode.removeChild(t), e;
};

supportsCssVars() || alert("Please view this demo in a modern browser that supports CSS Variables.");</script>
	</head>
	<body class="demo-2" style="background-color: #000000;">
		<!-- Shooting Stars Background Canvas -->
		<canvas class="stars-bg" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none;"></canvas>
		<main>
			<div class="content">
				<div class="grid">
					<div class="grid__item pos-1"><div class="grid__item-img" style="background-image:url(dino.png);"></div></div>
					<div class="grid__item pos-2"><div class="grid__item-img" style="background-image:url(dietcoke.png);"></div></div>
					<div class="grid__item pos-3"><div class="grid__item-img" style="background-image:url(kittyabduction.png);"></div></div>
					<div class="grid__item pos-4"><div class="grid__item-img" style="background-image:url(lego.png);"></div></div>
					<div class="grid__item pos-5"><div class="grid__item-img" style="background-image:url(lilweezy.png);"></div></div>
					<div class="grid__item pos-6"><div class="grid__item-img" style="background-image:url(mandoyoda.png);"></div></div>
					<div class="grid__item pos-7"><div class="grid__item-img" style="background-image:url(marioturtle.png);"></div></div>
					<div class="grid__item pos-8"><div class="grid__item-img" style="background-image:url(monkeycig.png);"></div></div>
					<div class="grid__item pos-9"><div class="grid__item-img" style="background-image:url(picklerick.png);"></div></div>
					<div class="grid__item pos-10"><div class="grid__item-img" style="background-image:url(holoship.png);"></div></div>
					<div class="grid__item pos-11"><div class="grid__item-img" style="background-image:url(alienspacemanrocket.png);"></div></div>
					<div class="grid__item pos-12"><div class="grid__item-img" style="background-image:url(arcade.png);"></div></div>
					<div class="grid__item pos-13"><div class="grid__item-img" style="background-image:url(chaosracoon.png);"></div></div>
					<div class="grid__item pos-14"><div class="grid__item-img" style="background-image:url(doyoulikemystickerskitty.png);"></div></div>
					<div class="grid__item pos-15"><div class="grid__item-img" style="background-image:url(eyegalxy.png);"></div></div>
					<div class="grid__item pos-16"><div class="grid__item-img" style="background-image:url(gameboy.png);"></div></div>
					<div class="grid__item pos-17"><div class="grid__item-img" style="background-image:url(grosseye.png);"></div></div>
					<div class="grid__item pos-18"><div class="grid__item-img" style="background-image:url(kittycracker.png);"></div></div>
					<div class="grid__item pos-19"><div class="grid__item-img" style="background-image:url(nointernet.png);"></div></div>
					<div class="grid__item pos-20"><div class="grid__item-img" style="background-image:url(threeeyedkitty.png);"></div></div>
				</div>
				<h2 class="content__title no-select">
					<span>Grip</span>
					<span class="content__title-sub">tapes</span>
				</h2>
			</div>
		</main>
        <svg class="cursor" width="80" height="80" viewBox="0 0 80 80">
			<circle class="cursor__inner" cx="40" cy="40" r="20"></circle>
		</svg>
		<!-- Re-enabled Codrops motion script -->
		<script src="demo2.44794d1a.js"></script>
		<script>
			// Remove loading class immediately
			document.body.classList.remove('loading');
			
			// Initialize direct DOM manipulation for dragging
			document.addEventListener('DOMContentLoaded', function() {
				console.log('DOM loaded - setting up drag functionality');
				setupDragging();
			});
			
			// Also set up on window load to ensure everything is ready
			window.addEventListener('load', function() {
				console.log('Window loaded - ensuring drag is set up');
				document.body.classList.remove('loading');
				setupDragging();
				
				// Position items randomly
				randomizePositions();
			});
			
			// Function to set up dragging
			function setupDragging() {
				console.log('Setting up dragging for all grid items');
				const gridItems = document.querySelectorAll('.grid__item');
				console.log('Found', gridItems.length, 'grid items');
				
				// Remove any existing listeners to avoid duplicates
				gridItems.forEach(item => {
					item.removeEventListener('mousedown', handleMouseDown);
					item.removeEventListener('touchstart', handleTouchStart);
				});
				
				// Add new listeners
				gridItems.forEach((item, index) => {
					console.log('Setting up item', index);
					
					// Store position directly on the element
					if (!item.dataset.x) item.dataset.x = '0';
					if (!item.dataset.y) item.dataset.y = '0';
					
					// Apply initial position
					updateItemPosition(item);
					
					// Add event listeners
					item.addEventListener('mousedown', handleMouseDown);
					item.addEventListener('touchstart', handleTouchStart, {passive: false});
				});
			}
			
			// Position items randomly across the screen in a centered pattern
			function randomizePositions() {
				const gridItems = document.querySelectorAll('.grid__item');
				const padding = 100; // Keep away from edges
				
				// Calculate center area (moved up)
				const centerX = window.innerWidth / 2;
				const centerY = window.innerHeight * 0.4; // Move center point up
				const spreadX = window.innerWidth * 0.35; // Use 35% of screen width for tighter grouping
				const spreadY = window.innerHeight * 0.3; // Use 30% of screen height for tighter grouping
				
				gridItems.forEach(item => {
					// Generate position relative to center
					const angle = Math.random() * Math.PI * 2;
					const distance = Math.random() * Math.min(spreadX, spreadY);
					
					// Calculate position using polar coordinates for better distribution
					const x = centerX + Math.cos(angle) * distance;
					const y = centerY + Math.sin(angle) * distance;
					
					// Ensure within bounds
					const boundedX = Math.max(padding, Math.min(window.innerWidth - padding, x));
					const boundedY = Math.max(padding, Math.min(window.innerHeight - padding, y));
					
					item.dataset.x = boundedX;
					item.dataset.y = boundedY;
					
					updateItemPosition(item);
				});
				
				console.log('Randomized positions for', gridItems.length, 'items in centered pattern');
			}
			
			// Update item position based on stored coordinates
			function updateItemPosition(item) {
				const x = parseFloat(item.dataset.x) || 0;
				const y = parseFloat(item.dataset.y) || 0;
				
				item.style.left = x + 'px';
				item.style.top = y + 'px';
			}
			
			// Mouse down handler
			function handleMouseDown(e) {
				console.log('Mouse down on item');
				e.preventDefault();
				
				const item = e.currentTarget;
				item.classList.add('dragging');
				
				// Calculate offset within the element
				const rect = item.getBoundingClientRect();
				const offsetX = e.clientX - rect.left;
				const offsetY = e.clientY - rect.top;
				
				// Store the offset on the element
				item.dataset.offsetX = offsetX;
				item.dataset.offsetY = offsetY;
				
				// Add move and up listeners to document
				document.addEventListener('mousemove', handleMouseMove);
				document.addEventListener('mouseup', handleMouseUp);
			}
			
			// Touch start handler
			function handleTouchStart(e) {
				console.log('Touch start on item');
				e.preventDefault();
				
				const item = e.currentTarget;
				item.classList.add('dragging');
				
				const touch = e.touches[0];
				const rect = item.getBoundingClientRect();
				const offsetX = touch.clientX - rect.left;
				const offsetY = touch.clientY - rect.top;
				
				item.dataset.offsetX = offsetX;
				item.dataset.offsetY = offsetY;
				
				document.addEventListener('touchmove', handleTouchMove, {passive: false});
				document.addEventListener('touchend', handleTouchEnd);
			}
			
			// Mouse move handler
			function handleMouseMove(e) {
				const item = document.querySelector('.dragging');
				if (!item) return;
				
				e.preventDefault();
				
				const offsetX = parseFloat(item.dataset.offsetX) || 0;
				const offsetY = parseFloat(item.dataset.offsetY) || 0;
				
				// Calculate new position
				const x = e.clientX - offsetX;
				const y = e.clientY - offsetY;
				
				// Update position
				item.dataset.x = x;
				item.dataset.y = y;
				updateItemPosition(item);
			}
			
			// Touch move handler
			function handleTouchMove(e) {
				const item = document.querySelector('.dragging');
				if (!item) return;
				
				e.preventDefault();
				
				const touch = e.touches[0];
				const offsetX = parseFloat(item.dataset.offsetX) || 0;
				const offsetY = parseFloat(item.dataset.offsetY) || 0;
				
				const x = touch.clientX - offsetX;
				const y = touch.clientY - offsetY;
				
				item.dataset.x = x;
				item.dataset.y = y;
				updateItemPosition(item);
			}
			
			// Mouse up handler
			function handleMouseUp() {
				console.log('Mouse up - ending drag');
				const item = document.querySelector('.dragging');
				if (item) {
					item.classList.remove('dragging');
				}
				
				document.removeEventListener('mousemove', handleMouseMove);
				document.removeEventListener('mouseup', handleMouseUp);
			}
			
			// Touch end handler
			function handleTouchEnd() {
				console.log('Touch end - ending drag');
				const item = document.querySelector('.dragging');
				if (item) {
					item.classList.remove('dragging');
				}
				
				document.removeEventListener('touchmove', handleTouchMove);
				document.removeEventListener('touchend', handleTouchEnd);
			}
			
			// Override any Codrops transform interference
			function overrideCodropsTransforms() {
				console.log('Overriding Codrops transforms');
				
				// Override the Codrops transform function
				if (window.Grid && window.Grid.prototype) {
					const originalTransform = window.Grid.prototype.render;
					
					window.Grid.prototype.render = function() {
						// Call original function
						originalTransform.apply(this, arguments);
						
						// Then restore our positions
						const gridItems = document.querySelectorAll('.grid__item');
						gridItems.forEach(item => {
							if (item.dataset.x && item.dataset.y) {
								updateItemPosition(item);
							}
						});
					};
				}
			}
			
			// Run override after a delay to ensure Codrops is loaded
			setTimeout(overrideCodropsTransforms, 2000);
			
			// Shooting Stars Background Animation
			const canvas = document.querySelector(".stars-bg");
			const ctx = canvas?.getContext("2d");
			
			if (canvas && ctx) {
				let stars = [];
				let shootingStars = [];
				let ufos = [];
				let ufoImg = null;
				let coolObjects = [];
				
				// Performance constants
				const MAX_SHOOTING_STARS = 8;
				const MAX_UFOS = 1;
				
				// UFO image
				function loadUFOImage() {
					ufoImg = new window.Image();
					ufoImg.src = "https://i.postimg.cc/HLXwNVzz/ufo.png";
				}
				loadUFOImage();
				
				// Resize canvas
				function resizeCanvas() {
					canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;
				}
				window.addEventListener("resize", resizeCanvas);
				resizeCanvas();
				
				// Create stars
				function createStars() {
					const area = canvas.width * canvas.height;
					const numStars = Math.floor(area * 0.00008);
					stars = Array.from({ length: numStars }, () => ({
						x: Math.random() * canvas.width,
						y: Math.random() * canvas.height,
						r: Math.random() * 0.7 + 0.5,
						opacity: Math.random() * 0.5 + 0.5,
						twinkleSpeed: Math.random() * 0.5 + 0.5,
						twinklePhase: Math.random() * Math.PI * 2,
					}));
				}
				createStars();
				window.addEventListener("resize", createStars);
				
				// Draw stars
				function drawStars() {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
					stars.forEach((star) => {
						star.opacity = 0.5 + Math.abs(Math.sin((Date.now() * 0.001) / star.twinkleSpeed + star.twinklePhase) * 0.5);
						ctx.beginPath();
						ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
						ctx.fillStyle = `rgba(255,255,255,${star.opacity})`;
						ctx.fill();
					});
				}
				
				// Create shooting star
				function createShootingStar() {
					const side = Math.floor(Math.random() * 4);
					let x, y, angle;
					if (side === 0) {
						x = Math.random() * canvas.width;
						y = 0;
						angle = 45 + Math.random() * 30;
					} else if (side === 1) {
						x = canvas.width;
						y = Math.random() * canvas.height;
						angle = 135 + Math.random() * 30;
					} else if (side === 2) {
						x = Math.random() * canvas.width;
						y = canvas.height;
						angle = 225 + Math.random() * 30;
					} else {
						x = 0;
						y = Math.random() * canvas.height;
						angle = 315 + Math.random() * 30;
					}
					const speed = 8 + Math.random() * 12;
					shootingStars.push({
						x, y, angle,
						length: 120 + Math.random() * 60,
						life: 0,
						maxLife: 80 + Math.random() * 40,
						speed,
						curveIntensity: (Math.random() - 0.5) * 0.03,
						sparkles: [],
					});
				}
				
				// Draw shooting stars
				function drawShootingStars() {
					shootingStars.forEach((star) => {
						star.angle += star.curveIntensity;
						const rad = (star.angle * Math.PI) / 180;
						const dx = Math.cos(rad) * star.speed;
						const dy = Math.sin(rad) * star.speed;
						star.x += dx;
						star.y += dy;
						star.life++;
						
						// Add sparkles
						if (Math.random() < 0.6) {
							star.sparkles.push({
								x: star.x + (Math.random() - 0.5) * 30,
								y: star.y + (Math.random() - 0.5) * 30,
								life: 0,
								maxLife: 20 + Math.random() * 15,
								opacity: 1,
							});
						}
						
						// Draw sparkles
						star.sparkles.forEach((sparkle) => {
							sparkle.life++;
							sparkle.opacity *= 0.93;
							ctx.save();
							ctx.globalAlpha = sparkle.opacity;
							ctx.beginPath();
							ctx.arc(sparkle.x, sparkle.y, 1.5, 0, Math.PI * 2);
							ctx.fillStyle = "#fff";
							ctx.fill();
							ctx.restore();
						});
						
						// Remove old sparkles
						star.sparkles = star.sparkles.filter(sparkle => sparkle.life < sparkle.maxLife);
						
						// Draw main shooting star
						ctx.save();
						ctx.translate(star.x, star.y);
						ctx.rotate(rad);
						
						const grad = ctx.createLinearGradient(0, 0, star.length, 0);
						grad.addColorStop(0, "rgba(255,255,255,0)");
						grad.addColorStop(0.2, "rgba(0, 0, 255, 0.4)");
						grad.addColorStop(0.6, "rgba(128, 0, 128, 0.8)");
						grad.addColorStop(1, "rgba(255,255,255,1)");
						
						ctx.fillStyle = grad;
						ctx.fillRect(0, -1.5, star.length, 3);
						
						ctx.fillStyle = "rgba(255,255,255,0.9)";
						ctx.fillRect(star.length * 0.9, -0.5, star.length * 0.1, 1);
						
						ctx.restore();
					});
					
					// Clean up shooting stars
					shootingStars = shootingStars.filter(star => 
						star.life < star.maxLife &&
						star.x > -100 && star.x < canvas.width + 100 &&
						star.y > -100 && star.y < canvas.height + 100
					);
					
					if (shootingStars.length > MAX_SHOOTING_STARS) {
						shootingStars = shootingStars.slice(-MAX_SHOOTING_STARS);
					}
				}
				
				// Create UFOs
				function createUFO() {
					const y = 60 + Math.random() * (canvas.height - 120);
					const speed = 2 + Math.random() * 2;
					const direction = Math.random() < 0.5 ? "right" : "left";
					ufos.push({
						x: direction === "right" ? -80 : canvas.width + 80,
						y, speed, direction,
						life: 0,
						maxLife: Math.floor(canvas.width / speed) + 120,
					});
				}
				setInterval(() => {
					if (Math.random() < 0.3) createUFO();
				}, 35000 + Math.random() * 25000);
				
				// Draw UFOs
				function drawUFOs() {
					ufos.forEach((ufo) => {
						if (!ufoImg.complete) return;
						ctx.save();
						ctx.globalAlpha = 0.85;
						ctx.drawImage(ufoImg, ufo.x, ufo.y, 64, 32);
						ctx.restore();
						
						// UFO glow
						ctx.save();
						ctx.globalAlpha = 0.25;
						ctx.beginPath();
						ctx.ellipse(ufo.x + 32, ufo.y + 40, 28, 8, 0, 0, Math.PI * 2);
						ctx.fillStyle = "rgba(200,255,255,0.3)";
						ctx.fill();
						ctx.restore();
					});
					
					// Move UFOs
					ufos.forEach((ufo) => {
						if (ufo.direction === "right") {
							ufo.x += ufo.speed;
						} else {
							ufo.x -= ufo.speed;
						}
						ufo.life++;
					});
					
					// Clean up UFOs
					ufos = ufos.filter(ufo => 
						ufo.x > -100 && ufo.x < canvas.width + 100 && ufo.life < ufo.maxLife
					);
					
					if (ufos.length > MAX_UFOS) {
						ufos = ufos.slice(-MAX_UFOS);
					}
				}
				
				// Animation loop
				function animate() {
					drawStars();
					drawShootingStars();
					drawUFOs();
					requestAnimationFrame(animate);
				}
				animate();
				
				// Create shooting stars periodically
				setInterval(() => {
					createShootingStar();
				}, 5000 + Math.random() * 2000);
			}
		</script>
		<script>
			// Simple and reliable drag functionality
			document.addEventListener('DOMContentLoaded', function() {
				console.log('Drag script loaded');
				
				const gridItems = document.querySelectorAll('.grid__item');
				console.log('Found grid items:', gridItems.length);
				
				gridItems.forEach(function(item, index) {
					console.log('Setting up drag for item', index);
					
					let isDragging = false;
					let startX, startY;
					let offsetX = 0, offsetY = 0;
					
					// Make sure the item can be interacted with
					item.style.position = 'relative';
					item.style.zIndex = '1';
					item.style.cursor = 'grab';
					
					// Mouse events
					item.addEventListener('mousedown', function(e) {
						console.log('Mouse down on item', index);
						e.preventDefault();
						e.stopPropagation();
						
						isDragging = true;
						startX = e.clientX - offsetX;
						startY = e.clientY - offsetY;
						
						item.style.cursor = 'grabbing';
						item.style.zIndex = '1000';
					});
					
					// Touch events
					item.addEventListener('touchstart', function(e) {
						console.log('Touch start on item', index);
						e.preventDefault();
						e.stopPropagation();
						
						isDragging = true;
						startX = e.touches[0].clientX - offsetX;
						startY = e.touches[0].clientY - offsetY;
						
						item.style.cursor = 'grabbing';
						item.style.zIndex = '1000';
					});
					
					// Global mouse move
					document.addEventListener('mousemove', function(e) {
						if (isDragging) {
							e.preventDefault();
							offsetX = e.clientX - startX;
							offsetY = e.clientY - startY;
							
							item.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
						}
					});
					
					// Global touch move
					document.addEventListener('touchmove', function(e) {
						if (isDragging) {
							e.preventDefault();
							offsetX = e.touches[0].clientX - startX;
							offsetY = e.touches[0].clientY - startY;
							
							item.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
						}
					});
					
					// Global mouse up
					document.addEventListener('mouseup', function() {
						if (isDragging) {
							console.log('Mouse up - stopping drag');
							isDragging = false;
							item.style.cursor = 'grab';
							item.style.zIndex = '1';
						}
					});
					
					// Global touch end
					document.addEventListener('touchend', function() {
						if (isDragging) {
							console.log('Touch end - stopping drag');
							isDragging = false;
							item.style.cursor = 'grab';
							item.style.zIndex = '1';
						}
					});
				});
				
				console.log('Drag setup complete');
			});
		</script>
	</body>
</html>